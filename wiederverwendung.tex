\chapter{Wiederverwendung von Software}

Bevor wir jedoch genauer auf die testgetriebene Wiederverwednung eingehen, möchten wir zunächst das Thema Wiederverwendung von Software allgemein betrachten. 

\section{Motivation}

Wie bereits eingangs erwähnt stehen Softwarefirmen vor einem immer stärkeren Konkurrenz-, Zeit- und Kostendruck. Die Anforderung bessere Software in kürzerer Zeit zu geringeren Kosten zu erstellen kann nur mithilfe verschiedenster Methoden u.a. der gezielten Wiederverwendung von Software realisiert werden.

Durch Wiederverwendung bereits entwickelter Software kann die Entwicklungszeit eines neuen System signifikant gemindert werden. Neben der reinen Entwicklungszeit wird somit auch die Zeit für Test und evtl. Validierung gespart. Die Wiederverwendung erhöht also die Produktivität. Die eingesparte Zeit wirkt sich natürlich auch positiv auf die Entwicklungskosten eines Projektes aus.

Des weiteren kann davon ausgegangen werden, das bereits exisitierende Softwarekomponenten eine höhere Zuverlässigkeit besitzen, da Fehler die evtl. im Entwurf oder der Implementierung gemacht wurden, durch den bereits stattgefundenen Einsatz aufgefallen und behoben sind. Dadurch wird implizit die Qualität der neu entwickelten Software erhöht.    

Gerade die höhere Zuverlässigkeit und Qualität der Software, sowie die Einsparung von Zeit und Kosten führen zu einer besseren Planbarkeit für das gesamte Projekt.

Ein weiterer Vorteil ist, dass die Wartbarkeit von Software wesentlich erleichtert wird da evtl. auftretende Fehler in der wiederverwendeten Komponente nur einmal und nicht n-fach behoben werden müssen.

Die Vorteile der Wiederverwendung von Software sind also eindeutig und nicht von der Hand zu weisen. 



\section{Was bedeutet Wiederverwendung?}

Da bisher der Begriff der Wiederverwendung bisher recht allgemein und abstrakt benutzt wurde, werden wir den Begriff zunächst definieren und die verschieden Ebenen der Wiederverwendung von Software erläutern.

\subsection{Begriffsdefinition}
In der Literatur finden sich vielzählige und oft recht unterschiedliche Definitionen für den Begriff der Software-Wiederverwendung.

So beschreibt \autocite{Kru92} den Begriff sehr allgemein wie folgt: 
\begin{description}
	\item[Software Reuse, \autocite{Kru92}] \enquote{ Software reuse is the process of creating software systems from existing software
rather than building software systems from scratch.} 
\end{description}

Ähnlich, allerdings aus eher technischer Sicht, beschreibt \autocite{diaz} den Begriff Software Reuse als:
\begin{description}
	\item[Software Reuse, \autocite{diaz}] \enquote{ Software reuse is the use of existing software components to construct a new system.} 
\end{description}

Laut \autocite{gall} findet sich in \autocite{freeman} eine noch allgemeiner gefasste Definition des Begriffs. Hier wird die Wiederverwendung nicht rein auf die Wiederverwendung von Code und Codefragmenten reduziert:

\begin{description}
	\item[Reusable Software Engineering, \autocite{gall}] \enquote{Reusable Software Engineering beschäftigt sich mit der Entwicklung von Software unter Wiederverwendung aller während der Software-Entwicklung generiterten Informationen.} 
\end{description}

\subsection{Abstraktionsebenen}
Wie obige Definitionen zeigen kann unter Wiederverwendung von Software weit mehr als die reine  Wiederverwendung von Code verstanden werden. Dies liegt vor allem daran, dass Wiederverwendung auf verschiedenen Asbtraktionsebenen durchgeführt werden kann, die wiederum neue Aspekte und Probleme mit sich bringen. Folgende Auflistung stellt eine Übersicht über die Verschiedenen Aspekte der Wiederverwendung und der möglichen Abstraktionsgrade dar und ist entnommen aus \autocite[vgl.][]{diaz}. Eine genaue Diskussion der einzelnen Punkte würde den Rahmen dieser Ausarbeitung sprengen,  sie gibnt jedoch eine guten Einblick in die Vielfältigkeit und Komplexität der Wiederverwendung von Software.

\begin{itemize}
	\item By substance
		\begin{itemize}
			\item ideas, concepts
			\item artifacts, components
			\item Procedures, Skills	
		\end{itemize}
	\item By scope
		\begin{itemize}
			\item Vertical
			\item Horizontal
		\end{itemize}
	\item By mode
		\begin{itemize}
			\item planned, systematic
			\item ad-hoc, opprtunistic
		\end{itemize}
			\item By technique
		\begin{itemize}
			\item compositional
			\item Generative
		\end{itemize}
			\item By intention
		\begin{itemize}
			\item black-box, as-is
			\item white-box, modified	
		\end{itemize}
			\item By product
		\begin{itemize}
			\item Source code
			\item Design
			\item Specifications
			\item Objects
			\item text
			\item architectures
		\end{itemize}
\end{itemize}
   
Die testgetriebene Wiederverwendung fokussiert die Wiederverwendung von Code-Fragmenten. Daher lehnen wir uns an die Definition von \autocite{diaz} und \autocite{Kru92} wenn im Folgenden der Begriff  Wiederverwendung von Software gebraucht wird.
   
\section{Probleme}

Die Wiederverwendung von Software ist seit beginn der Softwareentwicklung ein zentrales Thema. Der Begriff wurde erstmals von McIlroy 1968 geprägt. Er beschreibt in \autocite{mcilroy68mass} die damals katastrophale Lage der Softwareentwicklung und die Wiederverwendung als möglichen Ausweg aus der Softwarekrise.
 
Seitdem erhoffte man sich mit neuen Paradigmen der Softwareentwicklung stets auch die Wiederverwendung von Softwarekomponenten zu erleichtern und zu verbessern. Objektorientierte Programmierung und service-orientierte Architekturen sind nur wenige von vielen Beispielen dafür \autocite[vgl.][]{OS5/2011}

Und auch heutzutage gestaltet sich die Wiederverwendung von Software recht problematisch.[vgl] Doch warum lässt sich die recht einfache Idee der Wiederverwendung mit ihren vielen Vorteilen nur so schwer in die Praxis umsetzen? 

Das hauptsächliche Problem lässt sich recht einfach und anschaulich formulieren. 

\begin{center}
Software wiederverwendet heißt Software wiederfinden.
\end{center}

Aufgrund der rasant gestiegenen Open Source entwicklung ist die Anzahl an möglichen Kandidaten enorm gestiegen. War zu den Anfängen der Wiederverwendung von Software das Problem dass es zu wenige mögliche Kandidaten gab, so hat sich dies durch die Open Source Entwicklung ins Gegenteil gewendet. Jedoch ist dieser Umstand genauso problematisch. Die enorme Größe von Software-Repos kann von einem Entwickler kaum noch Inhaltlich durchschaut werden kann. Allein das aktuelle JDK umfasst ca. 3800 Basisklassen. Zieht man weitere bekannte Frameworks in die Rechnung mit ein kommt allein im Java-Umfeld auf 10.000 Klassen. 

Selbst Firmen-intern gestaltet sich das Wiederfinden von Software Komponenten oft schwierig. Oftmals geht entsprechendes Wissen über die Existenz entsprechender Komponenten mit dem Ausscheiden von Mitarbeiten verloren, oder wird nach Beendigung des Projekt schlicht vergessen. 