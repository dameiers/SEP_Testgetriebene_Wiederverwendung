\chapter{Testgetriebene Wiederverwendung}

\section{Idee der testgetriebenen Wiederverwendung}
%insgesamt finde ich das Kapitel hier zu kurz
%anbei ein paar ideen wie man das noch erweitern könnte

%ich würde noch genauer auf die Probleme eingehen, also suche oftmals nicht automatisiert, nicht integriert usw..

Um Komponenten wiederzuverwerten, muss der Benutzer diese über Suchmaschinen suchen, wobei die gefundenen Komponenten manuell überprüft und getestet werden müssen, ehe diese in einem Projekt verwendet werden können. Die Suchmaschinen liefern allerdings viele Komponenten, die den Anforderungen nicht entsprechen, sogenannte "False Positives". \autocite[vgl.][10]{OS5/2011} Diese False Positives kommen unter anderem zustande, da die Menge an Open-Source Code beachtlich ist und dieser Code durchaus wiederverwendet werden kann. Allerdings arbeiten die Suchmaschinen nicht gut genug um sämtliche falschen Ergebnisse herauszufiltern. Dies macht das manuelle heraus filtern sehr zeitaufwendig, so dass der Zeitgewinn bei der Wiederverwendung gering oder sogar negativ ausfällt und es schneller wäre die entsprechende Komponente neu zu schreiben. Diese Ungewissheit ob der Zeit gewonnen wird oder nicht, ist ein Argument gegen die Wiederverwendung, da durchaus viel Zeit verschwendet werden kann.

%hier genauer erläutern dass in agile methoden test first gilt und warum (quelle buch kent beck...)
Hier kommt nun die testgetriebene Wiederverwendung ins Spiel. Diese versucht die Anzahl der False Positives zu verringern, indem die gefundenen Komponenten automatisch geprüft und getestet werden. Dem Benutzer  werden nur die vielversprechenden Komponenten angezeigt, also jene die den Test überstanden haben. Somit wird dem Benutzer Arbeit abgenommen und das Wiederverwenden, aus Sicht des Benutzers, ist nicht mehr so zeitaufwändig. Die Idee dass die Komponenten automatisch getestet werden, ist dank Unit-Tests und den agilen Entwicklungsmethoden nicht so abwegig. Im konkreten Fall bedeutet dies, dass der Benutzer einen Unit-Test für eine Komponente schreibt, die noch nicht entwickelt wurde. Dies ist eine Herangehensweise, die besonders bei agilen Entwicklungsmethoden häufig anzutreffen ist. Da der Test den Aufbau der gesuchten Komponente beschreibt, kann eine Suchmaschine diesen als Suchanfrage verwenden, um nach ähnlichen Komponenten zu suchen. Danach können die gefundenen Komponenten mit jenem Test getestet werden und der Benutzer erhält als Suchergebnis nur noch die Komponenten, die den Test erfolgreich bestanden haben. Die gefundenen Ergebnisse passen per Definition ins Projekt des Benutzers, da sie den von ihm erstellten Test bestanden haben. 


\section{Vergleich und Stand von Tools}
Die in \autocite[11]{OS5/2011} erwähnten Werkzeuge, die eine testgetriebene Wiederverwendung ermöglichen, sind:
\begin{itemize}
	\item Code Genie
	\item S6
	\item Code Conjurer
\end{itemize}

%grund warum fokus auf code conjurer...
Diese 3 Werkzeuge werden im Folgenden, vorgestellt wobei auf Code Genie und S6 nur kurz eingegangen wird, und Code Conjurer ausführlicher betrachtet wird.

\subsection{Code Genie}
Die in \autocite[2]{Ota07} angegebene URL zu Code Genie existiert nicht mehr und es wurde auch sonst keine Möglichkeit gefunden um Code Genie herunterzuladen und zu testen. Laut \autocite[11]{OS5/2011} ist Code Genie ein Eclipse-Plug-In das die Suchmaschine Sourcerer benutzt. Allerdings verlangtes ein "'manuelles Integrieren und/oder Testen der Kandidaten in einer Kopie des eigenen Eclipse-Projektes."'

\subsection{S6}
S6 ist ein Web-Interface das über \autocite{s6search} erreichbar ist. Das Interface hat zwei große Nachteile:
\begin{itemize}
	\item Es können nur einfache Testfälle angegeben werden, die die Maske des Interfaces zulässt. Kompliziertere Unit-Tests sind somit nicht realisierbar, da das Hochladen von Dateien nicht möglich ist. Siehe in der Hilfe von: \autocite{s6search}
	\item Weiterhin fehlt eine Anbindung an eine Entwicklungsumgebung, wie etwa Eclipse, so dass das Arbeiten mit S6 recht umständlich ist. \autocite[10]{s6search}
\end{itemize}

\section{Code Conjurer}
Code Conjurer ist ein Eclipse Plug-In das testgetriebene Wiederverwendung für Java ermöglicht.
%welchem artikel
Beim Ausprobieren von Code Conjurer ist uns aufgefallen, dass das Werkzeug das wir benutzten stark von dem Abweicht was im Artikel beschrieben wird. Dies liegt daran dass im Artikel Code Conjurer 1 beschrieben wird. Allerdings wurde Code Conjurer zwischenzeitlich von Grund auf neu geschrieben \autocite{CC_SF}, so dass nur noch Code Conjurer 2 angeboten wird und die alte Version nicht mehr verfügbar ist. Das Problem ist allerdings, dass in der neuen Version noch einige Features fehlen. Im folgenden wird Code Conjurer 1 beschrieben und danach folgen unsere Erfahrungen mit Code Conjurer 2, sowie eine Auflistung mit den Fähigkeiten, die wir vermissen.

\subsection{Beschreibung von Code Conjurer 1}

Dieser Abschnitt beschreibt Code Conjurer 1, da diese Version des Werkzeugs, nicht mehr verfügbar war, wurde die Beschreibung aus \autocite[48-51]{Hum08}übernommen.

\subsubsection{Prinzipielle Funktionsweise von Code Conjurer 1}
%hier fände ich vlt einen beschrifteten screenshot ganz hilfreich...
\begin{itemize}
	\item In einem ersten Schritt schreibt der Benutzer einen JUnit-Test für die ungeschriebene Komponente, die er benötigt.
	\item In einem Status Feld, sieht der Benutzer eine Übersicht über die gefundenen Ergebnisse. In einem weiteren Fenster kann sich der Benutzer die Details zu der Suche explizit anzeigen lassen.
	\item Code Conjurer wird automatisch aktiv wenn der Benutzer den Test ausführt.
	\item Das Werkzeug sendet eine testgetriebene Suchanfrage an die Suchmaschine Merobase, welche die eigentlich Arbeit übernimmt.
	\begin{itemize}
 		\item Merobase erstellt ein Interface aus dem Testfall und sucht nach Komponenten, die auf diese zutreffen.
		\item Merobase teilt Code Conjurer die Anzahl der gefundenen Komponenten mit, welches es im Status Feld anzeigt.
		\item Danach testet Merobase die Kandidaten mit Hilfe des Testfalls, in einer abgesicherten virtuellen Maschine, und filtert jene Kandidaten aus, die den Test nicht bestanden haben.
	\end{itemize}
	\item Code Conjurer zeigt die Anzahl der erfolgreich getesteten Kandidaten in dem Status Feld an.
	\item In dem Fenster mit den Details zur Suche kann der Benutzer sich den Aufbau der gefundenen Komponenten anschauen, sowie den Quellcode überprüfen.
	\item Hat sich der Benutzer für eine Komponenten entschieden, kann er diese,per Drag-And-Drop zu seinem Projekt hinzufügen, wobei Code Conjurer die Abhängigkeiten automatisch auflöst.
\end{itemize}

\subsubsection{Weitere Funktionen von Code Conjurer 1}

Weitere Funktionen von Code Conjurer 1 sind die Automated Adaptation und Proactive Reuse Recommendations,die im Folgenden vorgestellt werden. 

\paragraph{Automated Adaptation}

In manchen Fällen werden nur wenige oder keine Komponenten gefunden, die mit dem Testfall übereinstimmen, aus diesem Grund bietet Code Conjurer die sogenannte Automated Adaptation. Dabei handelt es sich um Heuristiken, die z.B. Objekt- und Methodennamen ignoriert, so dass die Anzahl der gefundenen Komponenten erhöht wird. Außerdem, werden die Methoden so vertauscht, wenn dies möglich ist, dass mehr Testfälle durchlaufen werden können. Kurzum mit der Hilfe der Automated Adapation kann Code Conjurer Komponenten vorschlagen, die dem von Merobase erstellten Interface nicht entsprechen und trotzdem die benötigte Funktionalität liefern. Die Unterschiede zwischen der "'normalen"' Suche und Automated Adaptation sind der Tabelle in der Abbildung~\ref{fig:normalVSautomated} zu entnehmen.

Es fällt auf, dass teilweise deutlich mehr Kandidaten gefunden wurden und auch erfolgreich getestet werden konnten, allerdings hat sich die Ausführungszeit teilweise deutlich erhöht. Dies sieht man besonders beim Calculator Beispiel bei der die Dauer von 19 Sekunden auf 20 Stunden und 24 Minuten gestiegen ist. Trotzdem darf man diese Möglichkeit nicht außer acht lassen, da etwa bei Spreadsheet Beispiel mit der Automated Search 4 funktionierende Komponenten gefunden werden konnten, während die "'normale"' Suche zu keinem Ergebnis kam. 

\begin{center}
	\includegraphics[scale=0.5]{./img/normalSearchVSAutomatedAdapation.png}
	\caption{Vergleich der "'normalen"' Suche gegenüber von Automated Adapation}
	\label{fig:normalVSautomated}
\end{center}

\paragraph{Proactive Reuse Recommendations}

Code Conjurer kann den Entwickler proaktiv beim Designen seines Projektes unterstützen, in dem es ihm Vorschläge zu den noch unfertigen Klassen gibt. Damit der Benutzer nicht von seiner eigentlichen Arbeit, dem Designen von Klassen abgelenkt wird, schlägt Code Conjurer die Suche jedes mal automatisch an, sobald eine Methode zu der Klasse hinzugefügt, entfernt oder verändert wird. Die Vorschläge werden wie gewohnt angezeigt und können ins Projekt integriert werden.

Auch wenn der Benutzer die vorgeschlagenen Komponenten nicht benutzt, so unterstützt ihn Code Conjurer trotzdem, da er sieht welcher Aufbau ähnliche Klassen häufig besitzen. Dies Vorgehensweise kann somit das Design des Projektes verbessern, da keine geläufigen Methoden vergessen werden.
Als Beispiel, der Benutzer will eine Stack Klasse erstellen und schreibt eine Klasse mit folgendem Aufbau:
\begin{verbatim}
Stack{
    void push(Object o){}
    Object pop(){}	
}
\end{verbatim}
Daraufhin schlägt Code Conjurer folgende Klasse vor, von der er die zusätzlichen Methoden übernehmen kann.
\begin{verbatim}
Stack{
    boolean isEmpty(){}
    Object pop(){}
    void push(Object arg1){}
    Object top(){}	
}
\end{verbatim}

\subsubsection{Zusammenfassende Featureliste von Code Conjurer 1}

Aus den vorherigen Abschnitten kann eine Featureliste von Code Conjurer 1 erstellt werden, die dann später verwendet werden kann, um aufzuzeigen, welche Features bei Code Conjurer 2 fehlen.

\begin{itemize}
	\item Suche nach Klassen mit Hilfe des Klassenaufbaus
	\item Testgetriebene Suche
	\item Anzeigen einer Übersicht zu den Suchergebnisse in einem Status Feld
	\item Anzeigen der Suchergebnisse mit Quellcode
	\item Hinzufügen einer Komponente per Drag-And-Drop zum eigenen Projekt
	\item Automatisches Auflösen der Abhängigkeiten von einem hinzugefügten Projekt
	\item Automated Adaptation
	\item Proactive Reuse Recommendations
\end{itemize}

\subsection{Erfahrungen mit Code Conjurer 2}

Um Code Conjurer 2 zu testen wurden verschiedene Beispiele aus Abbildung~\ref{fig:normalVSautomated} verwendet. Die Durchführung war hier jedesmal die gleiche:
\begin{itemize}
	\item Klasse mit Methoden aus der Abbildung erstellen, wobei die Methoden leer bleiben
	\item Codebasierte Suche durchführen
	\item Testfall zu der Klasse schreiben
	\item Testbasierte Suche durchführen
\end{itemize}

\subsubsection{Shopping Card}

Bei diesem Beispiel soll eine Komponente für einen Einkaufswagen gefunden werden, dazu wurde eine Java Klasse angelegt, die den gleichen Aufbau hat, wie dies oben in der Abbildung gezeigt wird. In einem ersten Schritt soll Code Conjurer die normale Codesuche verwenden, diese findet allerdings keine Ergebnisse. Gibt man die Klasse bei Merobase direkt ein, so erhält man zwar Suchergebnisse, allerdings kann Merobase den Quellcode dieser Komponenten nicht mehr finden.
Ein weiteres Testen mit diesem Beispiel ist demnach sinnlos.

\subsubsection{Complex Number}

Bei der Suche nach Komponenten für komplexe Zahlen wurden zumindest Suchergebnisse gefunden, die auf den ersten Blick vielversprechend aussahen. Diese Ergebnisse sollten mit Hilfe der testgetriebenen Suche gefiltert werden. Allerdings konnte keine der Komponente den Test bestehen. Dies kann einerseits daran liegen, dass die Suche auf 30 Komponenten beschränkt ist. Diese Beschränkung ist von Merobase so vorgegeben, um die Server nicht zu sehr zu belasten. Andererseits kann es auch auf den Code zurückzuführen sein, den Merobase zur Verfügung steht. Stichprobenweise stellte sich heraus, dass die Methoden nicht implementiert waren, Methoden fehlten oder dass die Komponenten nichts mit komplexen Zahlen gemein hatten.

\subsubsection{Matrix}

Als letztes Beispiel wurde nach einer Matrix Komponente gesucht. Bei der normalen Codesuche wurden 30 Ergebnisse gefunden, demnach konnte mit der testgetriebenen Suche weitergemacht werden. Bei dieser Suche, konnten allerdings keine passenden Treffer gefunden werden. Gibt man den Testfall direkt bei Merobase an, so schlagen hier auch alle Testfälle fehl, wobei bei jedem Testfall die Fehlermeldung "'TestResult: error: compilation failed"' ausgegeben wird. Um sicher zu gehen, dass diese Fehlermeldung nicht auf den JUnit-Testfall zurückzuführen ist, wurde die Matrix Klasse von uns implementiert und der Testfall konnte lokal erfolgreich durchgeführt werden. Demnach ist unserer Testfall richtig und die eigentliche Suche bei Merobase schlägt fehl. 

\subsubsection{Fazit zu Code Conjurer 2}

Um Code Conjurer 2 zu bewerten, werden zu erst die einzelnen Features betrachtet, ehe ein Fazit über das gesamte Werkzeug abgegeben wird.

\begin{description}
	\item [Suche nach Klassen mit Hilfe des Klassenaufbaus]
		{Dieses Feature ist vorhanden und funktioniert, soweit Merobase brauchbare Resultate liefert.}
	\item [Testgetriebene Suche]
		{Dieses Feature ist ebenfalls vorhanden, es kann allerdings nicht behauptet werden, dass es funktioniert, weil die Resultate, die von Merobase zürckgegeben werden, nicht brauchbar sind.}
	\item [Anzeigen einer Übersicht zu den Suchergebnisse in einem Status Feld]
		{Dieses Feature ist nicht vorhanden.}
	\item [Anzeigen der Suchergebnisse mit Quellcode]
		{Ist vorhanden.}
	\item [Hinzufügen einer Komponente per Drag-And-Drop zum eigenen Projekt]
		{}
	\item [Automatisches Auflösen der Abhängigkeiten von einem hinzugefügten Projekt]
		{}
	\item [Automated Adaptation]
		{}
	\item [Proactive Reuse Recommendations]
		{}
\end{description}

Unterm Strich kann man festhalten, dass die codebasierte Suche funktioniert und der gefundene Code, in einigen Fällen, zu gebrauchen ist. Das Werkzeug ist allerdings hierfür nicht ausgelegt, so dass die entsprechenden Hilfsmittel fehlen. Mit der eigentlichen Hauptfunktionalität, der testgetriebenen Suche, konnten keine brauchbaren Ergebnisse erziehlt werden, so dass kein gefundener Code wiederverwendet werden konnte. 

